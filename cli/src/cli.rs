use argh::FromArgs;

use crate::patch::Patch as DirPatch;
use crate::plan::Plan as DirPlan;

/// Generate and apply binary patches
#[derive(FromArgs, PartialEq, Debug)]
pub struct Cli {
    #[argh(subcommand)]
    cmd: Command,
}

impl Cli {
    pub fn new() {
        let Cli { cmd } = argh::from_env();
        match cmd {
            Command::Diff(args) => {
                let plan = DirPlan::new(args.source, args.target);
                let patch = DirPatch::from_plan(plan);
                patch.write_file(&args.output);
            }
            Command::Patch(args) => {
                let patch = DirPatch::from_file(args.patch);
                patch.apply(&args.source);
            }
            Command::Plan(args) => {
                let plan = DirPlan::new(args.source, args.target);
                plan.print();
            }
        }
    }
}

#[derive(FromArgs, PartialEq, Debug)]
#[argh(subcommand)]
enum Command {
    Diff(Diff),
    Patch(Patch),
    Plan(Plan),
}

/// Calculate a plan for diffing two directories
#[derive(FromArgs, PartialEq, Debug)]
#[argh(subcommand, name = "plan")]
struct Plan {
    #[argh(positional)]
    source: String,
    #[argh(positional)]
    target: String,
}

/// Write the diff of two directories to a patch file
#[derive(FromArgs, PartialEq, Debug)]
#[argh(subcommand, name = "diff")]
struct Diff {
    #[argh(positional)]
    source: String,
    #[argh(positional)]
    target: String,
    #[argh(positional)]
    output: String,
}

/// Apply a patch file generated by this tool
#[derive(FromArgs, PartialEq, Debug)]
#[argh(subcommand, name = "patch")]
struct Patch {
    #[argh(positional)]
    source: String,
    #[argh(positional)]
    patch: String,
}
